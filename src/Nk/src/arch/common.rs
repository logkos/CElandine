use crate::bindings::{LPDWORD, WORD, DWORD, HANDLE, PROCESS, PTHREAD, LPBYTE, LPVOID, ULONG, LARGE_INTEGER, LONGLONG, LONG};

pub struct KDataCommon {
    pub lpvTls_pcb: LPDWORD,
    pub bResched_pcb: u8,
    pub cNest_pcb: u8,
    pub fIdle_pcb: WORD,
    pub CurThId_pcb: ULONG,
    pub ActvProcId_pcb: DWORD,
    pub CurTok_pcb: HANDLE,
    pub dwHardwareCPUId: DWORD,
    pub dwKCRes_pcb: DWORD,
    pub pVMPrc_pcb: *PROCESS,
    pub pCurPrc_pcb: PPROCESS,
    pub pCurThd_pcb: PTHREAD,
    pub ownspinlock_pcb: DWORD,
    pub pCurFPUOwner_pcb: PTHREAD,
    pub aPend1_pcb: DWORD,
    pub aPend2_pcb: DWORD,
    pub pKStack_pcb: LPBYTE,
    pub pthSched_pcb: PTHREAD,
    pub dwCpuId_pcb: DWORD,
    pub dwCpuState_pcb: DWORD,
    pub pSavedContext_pcb: LPVOID,
    pub dwTlbMissCnt_pcb: DWORD,
    pub dwSyscallReturnTrap: DWORD,
    pub dwPslTrapSeed: DWORD,
    pub pSelf_pcb: *mut PCB,
    pub wIPIPending_pcb: WORD,
    pub wIPIOperation_pcb: WORD,
    pub dwPrevReschedTime_pcb: DWORD,
    pub dwPrevTimeModeTime_pcb: DWORD,
    pub liIdleTime_pcb: LARGE_INTEGER,
    pub OwnerProcId_pcb: DWORD,
    pub unused_pcb: [DWORD; 4],
    pub wPad: WORD,
    pub bPowerOff: u8,
    pub bProfileOn: u8,
    pub nCpus: DWORD,
    pub dwKVMStart: DWORD,
    pub dwKDllFirst: DWORD,
    pub dwKDllEnd: DWORD,
    pub pAPIReturn: ULONG,
    pub nMemForPT: LONG,
    pub dwInDebugger: DWORD,
    pub dwTOCAddr: DWORD,
    pub dwStartUpAddr: DWORD,
    pub pOem: LPVOID,
    pub pNk: LPVOID,
    pub dwCelogStatus: DWORD,
    pub i64RawOfst: LONGLONG,
    pub dwOfstSysLocale: DWORD,
    pub dwOfstUsrLocale: DWORD,
    pub pOsAxsDataBlock: *mut OSAXS_KERN_POINTERS_2,
    pub dwIdKitlIST: DWORD,
    pub dwIdKitlTimer: DWORD,
    pub pOsAxsHwTrap: *mut OSAXS_HWTRAP,
    pub affinityQ_pcb: TWO_D_QUEUE,
    pub pagefreecount: LONG,
    pub MinPageFree: LONG,
    pub unused_kData: [LPVOID; 31],
    pub alpeIntrEvents: [PEVENT; 64],
}
